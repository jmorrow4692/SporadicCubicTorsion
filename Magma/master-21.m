//////////////////////////////////////////////////////////////////////////////////////////
// This is a complete determination of the cubic points on X1(21)
//////////////////////////////////////////////////////////////////////////////////////////
 
/****************************************************************************** 
 Here is a summary of the argument.
  - X1(21) has genus 5, and J1(21) has rank 0
  - There are 6 rational cusps, 3 quadratic cusps, and 2 sextic cusps
  - Najman's sporadic point gives 2 cubic points 
  - There are thus (6 + 3 -1 choose 3) + 6*3 + 2 = 76 rational degree 3 divisors
  - Torsion is Z/364Z, generated by a quadratic cusp - 2*(a rational cusp)
  - Sieving speeds this up greatly, but is not strictly necessary. 
    See the alt files for a faster verification.

******************************************************************************/

  N := 21;

  //////////////////////////////////////////////////////////////////////////////////////////
  // Input the homebrewed functions 
  //////////////////////////////////////////////////////////////////////////////////////////
  
  load "functions.m";

  
  //////////////////////////////////////////////////////////////////////////////////////////
  // Model of X1(21) from Sutherland
  //////////////////////////////////////////////////////////////////////////////////////////  
  
    F := Rationals();
    A2<x,y> := AffineSpace(F,2);
    X:=Curve(A2,y^4 + (3*x^2 + 1)*y^3 + (x^5 + x^4 + 2*x^2 + 2*x)*y^2 + (2*x^4 + x^3 + x)*y + x^3);
    // Genus(X); // 5

   
  //////////////////////////////////////////////////////////////////////
  // Get the canonical model.
  //////////////////////////////////////////////////////////////////////
  
    phi := CanonicalMap(ProjectiveClosure(X));
    Xsm := CanonicalImage(Domain(phi),phi); 
     P<[T]> := AmbientSpace(Xsm);

  
  //////////////////////////////////////////////////////////////////////
  // Compute the local torsion bound
  //////////////////////////////////////////////////////////////////////   

//  for p in [q : q in PrimesUpTo(40) | not q in PrimeDivisors(2*N) ] do
  torsData := {@@};
  for p in [5,11 ] do     
      invs := Invariants(ClassGroup(Curve(Reduction(Xsm,p))));
      torsData := torsData join {@invs@};
      <p,invs>;
  end for;

  /*
    [ 2184, 0 ]
    [ 14, 6916, 0 ]
  */       
  
    "The rational torsion subgroup is a subgroup of", torsBound(torsData); ; // 364

    
    ////////////////////////////////////////////////////////////////////////
    // Compute the known small degree points
    ////////////////////////////////////////////////////////////////////////

    pts := PointSearch(Xsm, 50);
    "There are", #pts, "rational points";

    /*
    pts := 
    [
        [ -2, -1, 0, 1, 0 ],
        [ -2, -1, 1, 0, 0 ],
        [ 1, 0, 0, 0, 0 ],
        [ -2, -2, 1, 1, 1 ],
        [ -2, -1, 1, 1, 0 ],
        [ -1, -1, 1, 1, 1 ]
    ];
    */
    
    basePt := [-1,-1,1,1,1];   

    // Find the ideals of the quadratic cusps
    pts2 := divisorSearch(Xsm,2,1);
    
    #pts2, "quadratic points"; // 2    
    
    /*
    [
        Place at (-1 : -1 : -$.1 + 1 : $.1 : 1),
        Place at (-3*$.1 + 2 : -2*$.1 : $.1 : $.1 : 1),
        Place at (1/2*(-10*$.1 - 31) : 1/4*(-10*$.1 - 33) : 2 : 2 : 1)
    ]
   */

    // Hard code the ideals defining the quadratic points
    eqns2 := {@
    [
        T[4]^2 - T[4]*T[5] + T[5]^2,
        T[1] + T[5],
        T[2] + T[5],
        T[3] + T[4] - T[5]
    ],
    [
        T[4]^2 - T[4]*T[5] + T[5]^2,
        T[1] + 3*T[4] - 2*T[5],
        T[2] + 2*T[4],
        T[3] - T[4]
    ],
    [
        T[2]^2 + 5*T[2]*T[5] + 7*T[5]^2,
        T[1] - 2*T[2] - T[5],
        T[3] - 2*T[5],
        T[4] - 2*T[5]
    ]
    @};

    // Hard code the ideals defining the quadratic points
    eqns3 :=
    {@
        [
            T[3]^2 - 4*T[3]*T[5] + 3*T[4]*T[5] - 2*T[5]^2,
            T[3]*T[4] + T[3]*T[5] - 2*T[4]*T[5] + T[5]^2,
            T[4]^2 - T[3]*T[5] - T[4]*T[5],
            T[1] + T[4] - T[5],
            T[2] + T[5]
        ],
        [
            T[2]^2 - T[2]*T[5] - 3*T[4]*T[5] - 5*T[5]^2,
            T[2]*T[4] + T[2]*T[5] + 4*T[4]*T[5] + T[5]^2,
            T[4]^2 - T[2]*T[5] - 4*T[4]*T[5],
            T[1] + T[4] + 2*T[5],
            T[3] - 2*T[5]
        ]
    @};

   "There are", Binomial(#pts + 3 - 1, 3) + #pts * #eqns2 + #eqns3, "rational cubic divisors";


  //////////////////////////////////////////////////////////////////////
  // Verify that the known points generate the torsion
  //////////////////////////////////////////////////////////////////////    

    p := 5;    

    Xp<[t]> := Curve(Reduction(Xsm,p));
      pic, mPic := ClassGroup(Xp);
      d := Dimension(AmbientSpace(Xp)) + 1;
      divs1Xp := {@ Divisor(Xp![GF(p)!pt[i] : i in [1..d]]) : pt in pts@};
      divs2Xp := {@Divisor(Xp,Scheme(Xp,[Parent(t[2])!e : e in eqn])) : eqn in eqns2 @};      
      divs3Xp := {@Divisor(Xp,Scheme(Xp,[Parent(t[2])!e : e in eqn])) : eqn in eqns3 @};      
      basePtXp := Divisor(Xp!basePt);


/*
      global1, mGlobal1 := sub<pic | [Inverse(mPic)(D - Degree(D)*basePtXp) : D in divs1Xp]>;
      Invariants(global1);
      // [182]      
      global2, mGlobal2 := sub<pic | [Inverse(mPic)(D - Degree(D)*basePtXp) : D in divs2Xp ]>;
      Invariants(global1);      
      // [364]

//      global, mGlobal := sub<pic | [Inverse(mPic)(D - Degree(D)*basePtXp) : D in {divs2Xp[1]} ]>;
//      Invariants(global1);      
      // [364]
*/      

      basisXp := [divs2Xp[1] - 2*basePtXp]; 
      [Order(Inverse(mPic)(D)) : D in basisXp];
      // [364]  

//    global, mGlobal := sub<pic | [Inverse(mPic)(D) : D in basisXp]>;
//      Invariants(global);
      // [364]
      

      
    ////////////////////////////////////////////////////////////////////////
    // Now determine the image of Abel--Jacobi
    ////////////////////////////////////////////////////////////////////////    

/*      
    // This works, but is very slow. 
    D := Divisor(Xsm,Scheme(Xsm,eqns2[1]));

    data := {@@};		 
time    for n in [0..364-1] do
      RnD,mRnD := RiemannRochSpace(n*D + 3*Divisor(Xsm!basePt));
      if Dimension(RnD) gt 0 then
	  data := data join {n};
      end if;     
    end for;   
    #data; // 76, so we are done!

    // takes ??? seconds
*/
    
   // Work mod p to speed it up

    dataXp := {@@};		 
    for n in [0..364-1] do
      RnD,mRnD := RiemannRochSpace(n*basisXp[1] +3*Divisor(Xp!basePt) );
      if Dimension(RnD) gt 0 then
	  dataXp := dataXp join {n};
      end if;     
    end for;   
    "X^(3)(Q) has size at most",  #dataXp; 
    // 76, so we are done! 
    // takes 8 seconds
          
    

   
